root ::= package_block* end_file?
package_block ::= package package_name semi ( package_import | sub_block | sub_call semi |  line_comment | block_comment | begin_statement | (my_statement | our_statement | general_statement))*
package_import ::= use package_name qw_block? semi
qw_block ::= qw '/' (predicate? identifier)+ '/' |  qw '(' (predicate? identifier)+ ')'
package_name ::= identifier (package_delimiter identifier)*
semi ::= ';'
eq ::= '='
package_delimiter ::= '::'
hash_accessor ::= '=>'
comma ::= ','
pointer ::= '->'
magic_args ::= 'regexp:\$\_' data_accessor? pointer?
array_last_index ::= 'regexp:\$\#' identifier
line_comment ::= 'regexp:#[^\r\n]*'
block_comment ::= 'regexp:=(head|head1|pod|for)((?!=cut)[\s\S])*=cut'
block_statement ::= '{' block? '}' semi? | '{' block? '}' pointer semi?
begin_statement ::= BEGIN block_statement
//sub_block ::= sub predicate? identifier block_statement semi?
sub_block ::= sub predicate? identifier block_statement
block ::= ( ( function_call | sub_call | my_statement | data_accessor assignment_statement?) semi? | sub_block | block_statement | general_statement | qw_block | value | line_comment | block_comment)*
my_statement ::= my general_statement
our_statement ::= our general_statement
general_statement ::= '('? variable_name (comma variable_name)* ')'? assignment_statement? semi?
assignment_statement ::= eq value short_if_statement?
map_statement ::= map '{' value (hash_accessor value)? '}' value
foreach_statement ::= foreach ( short_for_statement | value ) semi?
value ::=  (string | perl_var | array_last_index | hash_structure | sub_call | data_accessor | variable_name | qw_block | map_statement | foreach_statement | digit | short_for_statement | block_statement | list_values | identifier) ((and | or) defined? exists? value)* semi? line_comment?
short_for_statement ::= '(' value '..' value ')' | value '..' value
string ::= ('regexp:\".*\"' | "regexp:\'.*\'")
short_if_statement ::= ( if | unless ) ( defined | exists )? ('(' value ')' | value ) semi?
perl_var ::= 'regexp:\@\_'
identifier ::= 'regexp:[A-Za-z0-9\_]+' {}
whitespace ::= 'regexp:\s+'
variable_name ::= (predicate identifier | magic_args | package_name) operation? value? short_if_statement?
hash_structure ::= '{'? (( magic_args | identifier | variable_name ) hash_accessor (undef | magic_args | identifier | variable_name) comma)* (( magic_args | identifier | variable_name ) hash_accessor (undef | magic_args | identifier | variable_name) comma?)? '}'?
sub_call ::= variable_name pointer identifier list_values? | identifier list_values?
data_accessor ::= variable_name pointer? ( hash_key_block | array_key_block | block_statement ) (pointer? ( hash_key_block | array_key_block | block_statement ))* operation? value? line_comment?
hash_key_block ::= '{' ( identifier | variable_name ) '}'
array_key_block ::= '[' value ']'
break_line ::= ('\r' | '\n' | '\r\n')
predicate ::= 'regexp:\$\#'| 'regexp:(\\)?[\$\@\%\&]'
symbols ::= 'regexp:[^A-Za-z0-9]'
digit ::= (0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9)
function_call ::= function list_values? sub_call? short_if_statement?
list_values ::= ('(' ')' | '(' value (comma value)* comma? ')') | value (comma value)* comma?
function ::= ('abs'|'accept'|'alarm'|'atan2'|'AUTOLOAD'|'BEGIN'|'bless'|'return'|'bind'|'binmode'|'break'|'caller'|'chdir'|'CHECK'|'chmod'|'chomp'|'chop'|'chown'|'chr'|'chroot'|'close'|'closedir'|'connect'|'cos'|'crypt'|'dbmclose'|'dbmopen'|'defined'|'delete'|'DESTROY'|'die'|'dump'|'each'|'END'|'endgrent'|'endhostent'|'endnetent'|'endprotoent'|'endpwent'|'endservent'|'eof'|'eval'|'exec'|'exists'|'exit'|'fcntl'|'fileno'|'flock'|'fork'|'format'|'formline'|'getc'|'getgrent'|'getgrgid'|'getgrnam'|'gethostbyaddr'|'gethostbyname'|'gethostent'|'getlogin'|'getnetbyaddr'|'getnetbyname'|'getnetent'|'getpeername'|'getpgrp'|'getppid'|'getpriority'|'getprotobyname'|'getprotobynumber'|'getprotoent'|'getpwent'|'getpwnam'|'getpwuid'|'getservbyname'|'getservbyport'|'getservent'|'getsockname'|'getsockopt'|'glob'|'gmtime'|'goto'|'grep'|'hex'|'index'|'INIT'|'int'|'ioctl'|'join'|'keys'|'kill'|'last'|'lc'|'each'|'lcfirst'|'setnetent'|'length'|'link'|'listen'|'local'|'localtime'|'log'|'lstat'|'mkdir'|'msgctl'|'msgget'|'msgrcv'|'msgsnd'|'next'|'not'|'oct'|'open'|'opendir'|'ord'|'pack'|'pipe'|'pop'|'pos'|'print'|'printf'|'prototype'|'push'|'quotemeta'|'rand'|'read'|'readdir'|'readline'|'readlink'|'readpipe'|'recv'|'redo'|'ref'|'rename'|'req uire'|'reset'|'reverse'|'rewinddir'|'rindex'|'rmdir'|'say'|'scalar'|'seek'|'seekdir'|'select'|'semctl'|'semget'|'semop'|'send'|'setgrent'|'sethostent'|'each'|'lcfirst'|'setnetent'|'setpgrp'|'setpriority'|'setprotoent'|'setpwent'|'setservent'|'setsockopt'|'shift'|'shmctl'|'shmget'|'shmread'|'shmwrite'|'shutdown'|'sin'|'sleep'|'socket'|'socketpair'|'sort'|'splice'|'split'|'sprintf'|'sqrt'|'srand'|'stat'|'state'|'study'|'substr'|'symlink'|'syscall'|'sysopen'|'sysread'|'sysseek'|'system'|'syswrite'|'tell'|'telldir'|'tie'|'tied'|'time'|'times'|'truncate'|'uc'|'ucfirst'|'umask'|'undef'|'UNITCHECK'|'unlink'|'unpack'|'unshift'|'untie'|'utime'|'values'|'vec'|'wait'|'waitpid'|'wantarray'|'warn'|'write'|'each'|'lcfirst'|'setnetent')
end_file ::= 'regexp:\n1;' <<eof>>
operation ::= '>' | '++' | '--'